package net.codjo.spike.crts;
import net.codjo.spike.crts.Node;
import net.codjo.spike.crts.model.definition.*;

global Node rootNode;

function void debug(String text) {
    System.out.println("> " + text);
}

// TODO should probably use agenda-group over salience

// ------------------------------------------------------------------------------------------------
//   Initialisation
//   --------------
//     Apply direct definition (NodeDefinition and LinkDefinition)
// ------------------------------------------------------------------------------------------------

rule "Create a node for each NodeDefinition (aka 'Intermediate Node' in the original spec)"
  salience 100
when
    definition: NodeDefinition()
    not( Node( nodeDefinition == definition ) )
then
    debug(" create node for definition " + definition.getId());
    retract( definition );
    insert( new Node(definition) );
end

rule "Connect node using LinkDefinition (via ID)"
  salience 50
when
    link: LinkDefinition( type == LinkDefinition.Type.DIRECT )
    nodeFrom: Node( id == link.from )
    nodeTo: Node( id == link.to )
then
    debug(" Connect " + nodeFrom.getId() + " -> " + nodeTo.getId());
    nodeFrom.add( nodeTo );
    retract( link );
    update( nodeFrom );
end

rule "Connect node using LinkDefinition (via regexp)"
  salience 50
when
    link: LinkDefinition( type == LinkDefinition.Type.REGEXP)
    nodeFrom: Node( id matches ".*" )
    nodeTo: Node( id == link.to, this != nodeFrom, this not memberOf nodeFrom.nodes )
then
    debug(" Connect (via regexp)  " + nodeFrom.getId() + " -> " + nodeTo.getId());
    nodeFrom.add( nodeTo );
    // TODO: maybe we should use collect mechanism ?
    //      pros - we will be able to retract the link
    //      cons - we will have to iterate through the collections
    //  retract( link );
    update( nodeFrom );
end

// ------------------------------------------------------------------------------------------------
//   Connect Nodes
//   --------------
//
// ------------------------------------------------------------------------------------------------


// ------------------------------------------------------------------------------------------------
//   Tear down
//   --------------
//   Apply inferred definition (e.g. every orphaned node is automatically connected to the root node)
// ------------------------------------------------------------------------------------------------

rule "Assign orphan nodes to root"
  salience -100
when
    orphan: Node()
    not( Node( nodes contains orphan ) )
then
    debug(" orphan node " + orphan.getId());
    rootNode.add(orphan);
end

